// Generated by CoffeeScript 1.7.1
var Model, Q, User,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Q = require('q');

Model = require('../../core/models').Model;

User = (function(_super) {
  var _schemaDescription;

  __extends(User, _super);

  _schemaDescription = {
    firstName: String,
    lastName: String,
    email: String,
    username: String,
    password: String,
    tokens: Number
  };

  function User() {
    this._hiddenFields = ['password'];
    User.__super__.constructor.call(this, _schemaDescription);
  }

  User.prototype.save = function(inUserData, onComplete) {
    if (inUserData.email != null) {
      return this.isEmailExist(inUserData.email, (function(_this) {
        return function(isExist) {
          var exception;
          if (!isExist) {
            return _this._saveUser(inUserData, onComplete);
          } else {
            exception = new ExceptionUserMessage("error", "User with such email already exist");
            return onComplete(true, exception);
          }
        };
      })(this));
    }
  };

  User.prototype.findByEmailOrCreate = function(inUserData, onComplete) {
    return this.isEmailExist(inUserData.email, (function(_this) {
      return function(isExist) {
        if (isExist) {
          return _this.getByEmail(inUserData.email, onComplete);
        } else {
          return _this._saveUser(inUserData, function(err, exception) {
            if (!err) {
              return _this.getByEmail(inUserData.email, onComplete);
            } else {
              return onComplete(true, exception);
            }
          });
        }
      };
    })(this));
  };

  User.prototype.isEmailExist = function(inEmail, onComplete) {
    return this.getMongooseModel().findOne({
      'email': inEmail
    }).exec(function(err, result) {
      var isExist;
      isExist = result !== null;
      return onComplete(isExist);
    });
  };

  User.prototype.login = function(inEmail, inPassword) {
    var crypto, defer, password;
    defer = Q.defer();
    crypto = require('crypto');
    password = crypto.createHash('md5').update(inPassword).digest("hex");
    this.getMongooseModel().findOne({
      'email': inEmail,
      'password': password
    }, this._allowedFields).exec(function(err, result) {
      if (err) {
        return defer.reject(new ExceptionUserMessage("error", "DB error"));
      } else {
        if (result) {
          return defer.resolve(result);
        } else {
          return defer.reject(new ExceptionUserMessage("error", "Email or password is incorect"));
        }
      }
    });
    return defer.promise;
  };

  User.prototype.getTokens = function(inUserId) {
    var conditions, defer;
    defer = Q.defer();
    conditions = {
      "_id": inUserId
    };
    this.getMongooseModel().findOne(conditions, "tokens").exec(function(err, result) {
      if (err) {
        return defer.reject(new ExceptionUserMessage("error", "DB error"));
      } else {
        if (result) {
          return defer.resolve(result.tokens);
        } else {
          return defer.reject(new ExceptionUserMessage("error", "No user found"));
        }
      }
    });
    return defer.promise;
  };

  User.prototype.decrementTokens = function(inUserId) {
    var conditions, defer, options, update;
    defer = Q.defer();
    conditions = {
      "_id": inUserId
    };
    update = {
      $inc: {
        tokens: -1
      }
    };
    options = {};
    this.getMongooseModel().update(conditions, update, options, function(err, affected) {
      if (err) {
        return defer.reject(new ExceptionUserMessage("error", "DB error"));
      } else {
        return defer.resolve(affected);
      }
    });
    return defer.promise.then((function(_this) {
      return function() {
        return _this.getTokens(inUserId);
      };
    })(this));
  };

  User.prototype.getByEmail = function(inEmail, onComplete) {
    return this.getMongooseModel().findOne({
      'email': inEmail
    }, this._allowedFields).exec(function(err, user) {
      var exception;
      if (!err) {
        return onComplete(err, user);
      } else {
        exception = new ExceptionUserMessage("error", "Unable to find user with email (" + inEmail + ")");
        return onComplete(err, exception);
      }
    });
  };

  User.prototype._saveUser = function(inUserData, onComplete) {
    var crypto, doc;
    inUserData['linkCategories'] = [
      {
        name: 'Default'
      }
    ];
    crypto = require('crypto');
    inUserData.password = crypto.createHash('md5').update(inUserData.password).digest("hex");
    doc = this.createMongooseDocument(inUserData);
    return doc.save(function(err) {
      var exception;
      exception = null;
      if (err) {
        exception = new ExceptionUserMessage("error", "unable to save");
      }
      return onComplete(err, exception);
    });
  };

  return User;

})(Model.Mongo);

exports.User = User;
