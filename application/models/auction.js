// Generated by CoffeeScript 1.7.1
var Model, Q, mongoose,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Q = require('q');

Model = require('../../core/models').Model;

mongoose = require('mongoose');

exports.Auction = (function(_super) {
  var _schemaDescription;

  __extends(Auction, _super);

  _schemaDescription = {
    title: String,
    description: String,
    images: [String],
    bidders: [
      {
        userId: mongoose.Schema.ObjectId,
        username: String
      }
    ],
    lastBidder: {
      userId: mongoose.Schema.ObjectId,
      username: String
    },
    startingPrice: Number,
    currentPrice: Number,
    retailerPrice: Number,
    startDate: Date,
    endDate: Date
  };

  function Auction() {
    this._hiddenFields = ['bidders'];
    Auction.__super__.constructor.call(this, _schemaDescription);
  }

  Auction.prototype.save = function(inData) {
    var defer, doc;
    defer = Q.defer();
    doc = this.createMongooseDocument(inData);
    doc.save(function(err) {
      if (err) {
        return defer.reject(new ExceptionUserMessage("error", "Unable to save"));
      } else {
        return defer.resolve();
      }
    });
    return defer.promise;
  };

  Auction.prototype.findAll = function() {
    var defer;
    defer = Q.defer();
    this.getMongooseModel().find().exec(function(err, result) {
      if (err) {
        return defer.reject(new ExceptionUserMessage("error", "An error has occured while reading auctions"));
      } else {
        return defer.resolve(result);
      }
    });
    return defer.promise;
  };

  Auction.prototype.doBid = function(inAuctionId, inUser) {
    return Model.instanceOf('user').getTokens(inUser._id).then((function(_this) {
      return function(tokens) {
        var defer;
        if (tokens > 0) {
          return _this.getById(inAuctionId).then(function(auction) {
            var defer;
            if (auction.lastBidder.userId.toHexString() !== inUser._id.toHexString()) {
              return _this._doBid(inAuctionId, inUser);
            } else {
              defer = Q.defer();
              defer.resolve({
                auction: auction
              });
              return defer.promise;
            }
          });
        } else {
          defer = Q.defer();
          defer.reject(new ExceptionUserMessage("error", "You do not have tokens to continue bidding"));
          return defer.promise;
        }
      };
    })(this));
  };

  Auction.prototype._doBid = function(inAuctionId, inUser) {
    var bidder, conditions, defer, options, update;
    defer = Q.defer();
    options = {};
    conditions = {
      "_id": inAuctionId
    };
    bidder = {
      userId: inUser._id,
      username: inUser.username
    };
    update = {
      $addToSet: {
        bidders: bidder
      },
      lastBidder: bidder,
      $inc: {
        currentPrice: 0.01
      }
    };
    this.getMongooseModel().update(conditions, update, options, function(err, affected) {
      if (err) {
        return defer.reject(new ExceptionUserMessage("error", "DB error"));
      } else {
        return defer.resolve(affected);
      }
    });
    return defer.promise.then((function(_this) {
      return function() {
        return Model.instanceOf('user').decrementTokens(inUser._id).then(function(tokens) {
          return _this.getById(inAuctionId).then(function(auction) {
            var data, defer1;
            defer1 = Q.defer();
            data = {
              auction: auction,
              tokens: tokens
            };
            defer1.resolve(data);
            return defer1.promise;
          });
        });
      };
    })(this));
  };

  return Auction;

})(Model.Mongo);
